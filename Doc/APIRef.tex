\section{API Reference}
\subsection{Preprocessor constants}

\newcolumntype{b}{>{\hsize=.66\hsize}X}
\newcolumntype{s}{>{\hsize=.33\hsize}X}

\newcommand{\tblx}[2]{
	\noindent
	\begin{tabularx}{\textwidth} { | >{\raggedright\arraybackslash}X |  }
		\hline
		\texttt{#1} \\
		\hline
		#2 \\
		\hline
	\end{tabularx}
	\mbox{}\\

}

\newcommand{\tbly}[3]{
	\noindent
	\begin{tabularx}{\textwidth}{|s|b|}
		\midrule % hline
			#1 & \texttt{#2} \\
		\midrule % hline
			\multicolumn{2}{|l|}{\begin{minipage}{0.9\linewidth} \noindent #3 \end{minipage}} \\ % \rule{0pt}{2ex} \rule{0pt}{2ex} 
		\midrule % hline
	\end{tabularx}
	\mbox{}
}

\paragraph{Error names + codes}
\mbox{}\\

% DS5W_OK
\tblx{DS5W\_OK 0}{The operation completed without an error }

% DS5W_E_UNKNOWN
\tblx{DS5W\_E\_UNKNOWN 1}{An unknown error occurred }

% DS5W_E_INSUFFICIENT_BUFFER
\tblx{DS5W\_E\_INSUFFICIENT\_BUFFER 2}{The user supplied buffer is to small }

% DS5W_E_EXTERNAL_WINAPI
\tblx{DS5W\_E\_EXTERNAL\_WINAPI 3}{An unsuspected Windows sided error occurred}

% DS5W_E_STACK_OVERFLOW
\tblx{DS5W\_E\_STACK\_OVERFLOW 4}{The API tried to allocate memory on the stack but failed}

% DS5W_E_INVALID_ARGS
\tblx{DS5W\_E\_INVALID\_ARGS 5}{The user supplied arguments are invalid}

% DS5W_E_CURRENTLY_NOT_SUPPORTED
\tblx{DS5W\_E\_CURRENTLY\_NOT\_SUPPORTED 6}{This feature is currently not supported}

% DS5W_E_DEVICE_REMOVED
\tblx{DS5W\_E\_DEVICE\_REMOVED 7}{The device is not connected either physically or digitally}

% DS5W_E_BT_COM
\tblx{DS5W\_E\_BT\_COM 8}{Bluetooth communication error}

% DS5W_E_IO_TIMEOUT
\tblx{DS5W\_E\_IO\_TIMEOUT 9}{Windows IO operation was cancelled due to taking too long}

% DS5W_E_IO_FAILED
\tblx{DS5W\_E\_IO\_FAILED  10}{Windows IO operation failed}

% DS5W_E_IO_NOT_FOUND
\tblx{DS5W\_E\_IO\_NOT\_FOUND  11}{Windows IO operation was missing}

% DS5W_E_IO_PENDING
\tblx{DS5W\_E\_IO\_PENDING  12}{Windows IO operation did not complete but is running in background}



\paragraph{Error helpers}
\mbox{}\\

% DS5W_SUCCESS(expr)
\tblx{DS5W\_SUCCESS(expr)}{Check if the user supplied expression is an error success code}

% DS5W_FAILED(expr)
\tblx{DS5W\_FAILED(expr)}{Check if the user supplied expression is an error code}



\paragraph{I/O State helpers}
\mbox{}\\

% SQUARE / CROSS / CIRCLE / TRIANGLE
\tblx{DS5W\_ISTATE\_BTN\_SQUARE}{PlayStation Square button}
\tblx{DS5W\_ISTATE\_BTN\_CROSS}{PlayStation Cross button}
\tblx{DS5W\_ISTATE\_BTN\_CIRCLE}{PlayStation Circle button}
\tblx{DS5W\_ISTATE\_BTN\_TRIANGLE}{PlayStation Triangle button}

% DPAD
\tblx{DS5W\_ISTATE\_BTN\_DPAD\_LEFT}{D-Pad left}
\tblx{DS5W\_ISTATE\_BTN\_DPAD\_DOWN}{D-Pad down}
\tblx{DS5W\_ISTATE\_BTN\_DPAD\_RIGHT}{D-Pad right}
\tblx{DS5W\_ISTATE\_BTN\_DPAD\_UP}{D-Pad up}

% Other Buttons
\tblx{DS5W\_ISTATE\_BTN\_BUMPER\_LEFT}{Left bumper button}
\tblx{DS5W\_ISTATE\_BTN\_BUMPER\_RIGHT}{Right bumper button}
\tblx{DS5W\_ISTATE\_BTN\_TRIGGER\_LEFT}{Left trigger binary input}
\tblx{DS5W\_ISTATE\_BTN\_TRIGGER\_RIGHT}{Right trigger binary input}
\tblx{DS5W\_ISTATE\_BTN\_SELECT}{Select / Share button}
\tblx{DS5W\_ISTATE\_BTN\_MENU}{Menu Button}
\tblx{DS5W\_ISTATE\_BTN\_STICK\_LEFT}{Left stick push button}
\tblx{DS5W\_ISTATE\_BTN\_STICK\_RIGHT}{Right stick push button}
\tblx{DS5W\_ISTATE\_BTN\_PLAYSTATION\_LOGO}{PlayStation logo button}
\tblx{DS5W\_ISTATE\_BTN\_PAD\_BUTTON}{The touch-pads integrated button}
\tblx{DS5W\_ISTATE\_BTN\_MIC\_BUTTON}{Microphone mute button}

% Outstate
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_LEFT}{Left player indicator LED bit-mask}
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_MIDDLE\_LEFT}{Left middle player indicator LED bit-mask}
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_MIDDLE}{Middle player indicator LED bit-mask}
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_MIDDLE\_RIGHT}{Right middle player indicator LED bit-mask}
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_RIGHT}{Right player indicator LED bit-mask}

\subsection{Types}
\paragraph{DeviceEnumInfo} This struct contains all internal data required for the controller enumeration. You should not read or write any of the internal data directly. The struct can be freely user allocated with random data. It will be initialized by the corresponding function call, don't use it before it got initialized by the corresponding function.

\paragraph{DeviceContext} This struct contains all internal data for reading and writing to the controller. You should not read or write any of the internal data directly. The struct can be freely user allocated with random data. It will be initialized by the corresponding function call, don't use it before it got initialized by the corresponding function. It is very important to free this data with the corresponding function before the application exits or memory is reused. 

\label{APIRef_Types_analstick}
\paragraph{AnalogStick} This struct represent the XY position of one analog stick. Make sure to implement dead zones by yourself! \\

\tbly{int8\_t}{x}{X Position (left to right) of the analog stick.} \\

\tbly{int8\_t}{y}{Y Position (top to bottom) of the analog stick.} \\

\label{APIRef_Types_vec3}
\paragraph{Vector3, Vec3} Represents a three component 16-Bit vector \\

\tbly{int16\_t}{x}{X Component.} \\

\tbly{int16\_t}{y}{Y Component.} \\

\tbly{int16\_t}{z}{Z Component.} \\

\label{APIRef_Types_color}
\paragraph{Color} RGB 8-Bit color components. The library also provides several conversion functions to turn several color formats into 8-Bit RGB values.\\

\tbly{uint8\_t}{r}{R - Red color channel.}\\

\tbly{uint8\_t}{g}{G - Green color channel.}\\

\tbly{uint8\_t}{b}{B - Blue color channel.}\\

\label{APIRef_Types_touch}
\paragraph{Touch} This struct contains information about a single fingers touch position. \\

\tbly{int8\_t}{x}{X Position of the finger (left to right).} \\

\tbly{int8\_t}{y}{Y Position of the finger (top to bottom).} \\

\tbly{bool}{down}{Whether a finger is touching the touchpad} \\

\tbly{uint8\_t}{id}{7-Bit id of last touch (resets after 127). Counter is shared by each touch point and is not unique. } \\

\label{APIRef_Types_battery}
\paragraph{Battery} This struct contains information about the battery level. (work in progress)\\

\tbly{bool}{charging}{Whether the device is currently charging.} \\

\tbly{boolt}{fullyCharged}{Whether the battery is full} \\

\tbly{uint8\_t}{level}{current battery level  (0-100)} \\

\label{APIRef_Types_micled}
\paragraph{MicLed} Enum class representation the state of the orange microphone LED. \\

\tblx{OFF}{Microphone LED is off.}
\tblx{ON}{Microphone LED is on.}
\tblx{PULSE}{Microphone LED is pulsing.}


\label{APIRef_Types_tfxt}
\paragraph{TriggerEffectType} Enum class: feedback / effect type of the adaptive trigger.\\

\tblx{NoResitance}{Adaptive trigger is disabled. Will provide no resistance.}
\tblx{ContinuousResitance}{Adaptive trigger will provide a continuous resistance from a specific starting point.}
\tblx{SectionResitance}{Adaptive trigger will provide a force fixed resistance on a defined section.}
\tblx{EffectEx}{Adaptive trigger will execute an extended effect.}
\tblx{ReleaseAll}{Adaptive trigger will disable and release any active effects immediately.}
\tblx{Calibrate}{Adaptive trigger will enter an fixed function calibration program. Still experimental use only!}

\label{APIRef_Types_trigfx}
\paragraph{TriggerEffect}
This struct represents an adaptive trigger effect. The struct is 11 bytes long with the first byte being the effect type and the remaining being parameters. Not all parameters are used in trigger effects.\\

\tbly{\hyperref[APIRef_Types_tfxt]{TriggerEffectType}}{effectType}{Type of the effect. Chose next data according to this parameter.}\\

\noindent
When \texttt{effectType} == \texttt{NoResitance} no parameter needs to be set!\\
When \texttt{effectType} == \texttt{Calibrate} no parameter needs to be set!\\
When \texttt{effectType} == \texttt{ContinuousResitance}:\\

\tbly{uint8\_t}{Continuous.startPosition}{Start position of the continuous force.}\\

\tbly{uint8\_t}{Continuous.endPosition}{Force applied.}\\

\noindent
When \texttt{effectType} == \texttt{SectionResitance}:\\

\tbly{uint8\_t}{Section.startPosition}{Start of force increased area.}\\

\tbly{uint8\_t}{Section.force}{End of force increased area.}\\

\noindent
When \texttt{effectType} == \texttt{EffectEx}:\\

\tbly{uint8\_t}{EffectEx.startPosition}{Start positions of the effect.}\\

\tbly{bool}{EffectEx.keepEffect}{Indicates weather the effect should keep playing (vibration) when the trigger is fully pressed.}\\

\tbly{uint8\_t}{EffectEx.beginForce}{Force for the section with trigger value $\geq 128$.}\\

\tbly{uint8\_t}{EffectEx.middleForce}{Force for the section with trigger value $\leq 128$.}\\

\tbly{uint8\_t}{EffectEx.endForce}{Force applied when the trigger is fully pressed / would go beyond 255.}\\

\tbly{uint8\_t}{EffectEx.frequency}{Frequency with witch the effect is executed. More a scalar value to scale between two fixed frequency than an real frequency parameter.}\\


\label{APIRef_Types_ledbr}
\paragraph{LedBrightness} Enum class representation the brightness of the player indication LEDs.\\

\tblx{LOW}{Low brightness player indication LEDs.}
\tblx{MEDIUM}{Medium brightness player indication LEDs.}
\tblx{HIGH}{High brightness player indication LEDs.}

\label{APIRef_Types_pleds}
\paragraph{PlayerLeds} Struct defining the player LDEs state.\\

\tbly{Bitmask / uint8\_t}{bitmask}{Bitmask of the enabled player indication LEDs. Or together all enabled LEDs by using the \texttt{DS5W\_OSTATE\_PLAYER\_LED\_XXXXX} macros.}\\

\tbly{bool}{playerLedFade}{Indicates weather the player LEDs should fade in when enabled.}\\

\tbly{\hyperref[APIRef_Types_ledbr]{LedBrightness}}{brightness}{Brightness of the player LEDs.}\\


\paragraph{DS5InputState} 
This struct represents the parsed form of the raw input state from a DualSense controller. It is used to easily read input data from your own programs.\\

\tbly{\hyperref[APIRef_Types_analstick]{AnalogStick}}{leftStick}{Represents the position of the left analog stick.}\\

\tbly{\hyperref[APIRef_Types_analstick]{AnalogStick}}{rightStick}{Represents the position of the right analog stick.}\\

\tbly{Bitmask / uint32\_t}{buttonsMap}{Bitmask of all binary buttons. Check individual button states by doing bitwise \& with button flag macros.}\\

\tbly{uint8\_t}{leftTrigger}{8-Bit position of the left trigger. No dead zones required!}\\

\tbly{uint8\_t}{rightTrigger}{8-Bit position of the right trigger. No dead zones required!}\\

\tbly{\hyperref[APIRef_Types_vec3]{Vector3}}{accelerometer}{Positional acceleration vector (m/s).}\\

\tbly{\hyperref[APIRef_Types_vec3]{Vector3}}{gyroscope}{Angular velocity vector (degrees/s).}\\

\tbly{\hyperref[APIRef_Types_touch]{Touch}}{touchPoint1}{First touch point.}\\

\tbly{\hyperref[APIRef_Types_touch]{Touch}}{touchPoint2}{Second touch point.}\\
		
\tbly{uint32\_t}{currentTime}{Time that the input state was read at (measured in 0.33 microseconds)}\\

\tbly{uint32\_t}{deltaTime}{Time since the previous input state was read (measured in 0.33 microseconds)}\\

\tbly{\hyperref[APIRef_Types_battery]{Battery}}{battery}{Battery info.}\\

\tbly{bool}{headPhoneConnected}{Indicates weather a plug is present in the headphone jack. Will also trigger on an extension cord with no headphone connected!}\\

\tbly{uint8\_t}{leftTriggerFeedback}{Indicates the pressing force when the left adaptive trigger is active.}\\

\tbly{uint8\_t}{rightTriggerFeedback}{Indicates the pressing force when the right adaptive trigger is active.}\\

\paragraph{DS5OutputState}
This struct represents the output state of a DualSense controller. It is used to set all output data. \\

\tbly{uint8\_t}{leftRumble}{Force of the left (hard) rumble motor.}\\

\tbly{uint8\_t}{rightRumble}{Force of the right (soft) rumble motor.}\\

\tbly{uint8\_t}{rumbleStrength}{Strength of the rumble/haptic (trigger) motors. First 4 bits (0-3) represent the rumble motors and last 4 (4-7) represent the trigger's haptics strength.}\\

\tbly{\hyperref[APIRef_Types_micled]{MicLed}}{microphoneLed2}{State of the microphone LED.}\\

\tbly{bool}{disableLeds}{When active the lightbar will be set to the default PS5 blue.}\\

\tbly{\hyperref[APIRef_Types_pleds]{PlayerLeds}}{playerLeds}{State of the player LEDs.}\\

\tbly{\hyperref[APIRef_Types_color]{Color}}{lightbar}{RGB Color of the lightbar. No affect when \texttt{disableLeds} is \texttt{true}.}\\

\tbly{\hyperref[APIRef_Types_trigfx]{TriggerEffect}}{leftTriggerEffect}{Effect of the left adaptive trigger.}\\

\tbly{\hyperref[APIRef_Types_trigfx]{TriggerEffect}}{rightTriggerEffect}{Effect of the right adaptive trigger.}
\newpage

\subsection{Functions}

\paragraph{DS5W::enumDevices(...)}
Fill array with enumerable list of DualSense devices.\\


\paragraph{DS5W::enumUnknownDevices(...)}
Fill array with enumerable list of DualSense devices without doubles by passing in an array of known device IDs\\


\paragraph{DS5W::initDeviceContext(...)}
Initializes the context for a specific controller.\\


\paragraph{DS5W::freeDeviceContext(...)}
Frees a context from a controller witch is no longer required. Context cannot be reconnected and must be re-enumerated to be used again.\\


\paragraph{DS5W::shutDownDevice(...)}
Takes a working DualSense controller and releases it in Windows but does not forget it. Device can be reconnected again.\\


\paragraph{DS5W::reconnectDevice(...)}
Tries to reconnect a disconnected device. Device could have been lost due to a shutdown or been unplugged.\\


\paragraph{DS5W::getDeviceInputState(...)}
Retrieve the current input state of the device. Blocks thread for up to 100 milliseconds until input is received and parsed.\\


\paragraph{DS5W::setDeviceOutputState(...)}
Sets the desired output state of the device.  Blocks thread for up to 100 milliseconds until output is parsed and sent.\\


\paragraph{DS5W::startInputRequest(...)}
Begin a non-blocking request for an input report. Returns whether report was read instantly, or Windows is waiting for next report.\\


\paragraph{DS5W::awaitInputRequest(...)}
Blocks thread until previous input request was fulfilled (or timeout). \\


\paragraph{DS5W::getHeldInputState(...)}
Parses internal buffer into an input state. Uses whatever content was last read. Intended for use after startInputRequest/getHeldInputState.\\


\paragraph{DS5W::color\_R32G32B32\_FLOAT(...)} 
Converts a three component (RGB) normalized float color to the internal RGB 8-Bit formate.\\


\paragraph{DS5W::color\_R32G32B32A32\_FLOAT(...)}
Converts a four component (RGBA) normalized float color to the internal RGB 8-Bit formate.\\


\paragraph{DS5W::color\_R8G8B8A8\_UCHAR(...)}
Converts a four component (RGBA) unsigned char color (8-Bit) to the internal RGB 8-Bit formate.\\


\paragraph{DS5W::color\_R8G8B8\_UCHAR\_A32\_FLOAT(...)}
Scales a three component (RGB) unsigned char color (8-Bit) by a normalized float (A).\\



\newpage