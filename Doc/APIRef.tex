\section{API Reference}
\subsection{Preprocessor constants}

\newcolumntype{b}{>{\hsize=.66\hsize}X}
\newcolumntype{s}{>{\hsize=.33\hsize}X}

\newcommand{\tblx}[2]{
	\noindent
	\begin{tabularx}{\textwidth} { | >{\raggedright\arraybackslash}X |  }
		\hline
		\texttt{#1} \\
		\hline
		#2 \\
		\hline
	\end{tabularx}
	\mbox{}\\

}

\newcommand{\tbly}[3]{
	\noindent
	\begin{tabularx}{\textwidth}{|s|b|}
		\midrule % hline
			#1 & \texttt{#2} \\
		\midrule % hline
			\multicolumn{2}{|l|}{\begin{minipage}{0.9\linewidth} \noindent #3 \end{minipage}} \\ % \rule{0pt}{2ex} \rule{0pt}{2ex} 
		\midrule % hline
	\end{tabularx}
	\mbox{}
}

\paragraph{Error codes}
\mbox{}\\

% DS5W_OK
\tblx{DS5W\_OK}{The operation completed without an error}

% DS5W_E_UNKNOWN
\tblx{DS5W\_E\_UNKNOWN}{An unknown error occurred}

% DS5W_E_INSUFFICIENT_BUFFER
\tblx{DS5W\_E\_INSUFFICIENT\_BUFFER}{The user supplied buffer is to small }

% DS5W_E_EXTERNAL_WINAPI
\tblx{DS5W\_E\_EXTERNAL\_WINAPI}{An unsuspected Windows sided error occurred}

% DS5W_E_INVALID_ARGS
\tblx{DS5W\_E\_INVALID\_ARGS}{The user supplied arguments are invalid}

% DS5W_E_CURRENTLY_NOT_SUPPORTED
\tblx{DS5W\_E\_CURRENTLY\_NOT\_SUPPORTED}{This feature is currently not supported}

% DS5W_E_DEVICE_REMOVED
\tblx{DS5W\_E\_DEVICE\_REMOVED}{The device was removed unexpectedly}

% DS5W_E_BT_COM
\tblx{DS5W\_E\_BT\_COM}{Bluetooth communication error}

% DS5W_E_IO_TIMEOUT
\tblx{DS5W\_E\_IO\_TIMEOUT}{Windows IO operation did not complete in time}

% DS5W_E_IO_FAILED
\tblx{DS5W\_E\_IO\_FAILED}{Windows IO operation failed}



\paragraph{Error helpers}
\mbox{}\\

% DS5W_SUCCESS(expr)
\tblx{DS5W\_SUCCESS(expr)}{Check if the user supplied expression is an error success code}

% DS5W_FAILED(expr)
\tblx{DS5W\_FAILED(expr)}{Check if the user supplied expression is an error code}



\paragraph{I/O State helpers}
\mbox{}\\

% DS5W_ISTATE_BTX_SQUARE / CROSS / CIRCLE / TRIANGLE
\tblx{DS5W\_ISTATE\_BTX\_SQUARE}{PlayStation Square button}
\tblx{DS5W\_ISTATE\_BTX\_CROSS}{PlayStation Cross button}
\tblx{DS5W\_ISTATE\_BTX\_CIRCLE}{PlayStation Circle button}
\tblx{DS5W\_ISTATE\_BTX\_TRIANGLE}{PlayStation Triangle button}

% DPAD
\tblx{DS5W\_ISTATE\_DPAD\_LEFT}{D-Pad left}
\tblx{DS5W\_ISTATE\_DPAD\_DOWN}{D-Pad down}
\tblx{DS5W\_ISTATE\_DPAD\_RIGHT}{D-Pad right}
\tblx{DS5W\_ISTATE\_DPAD\_UP}{D-Pad up}

% Button A
\tblx{DS5W\_ISTATE\_BTN\_A\_LEFT\_BUMPER}{Left bumper button}
\tblx{DS5W\_ISTATE\_BTN\_A\_RIGHT\_BUMPER}{Right bumper button}
\tblx{DS5W\_ISTATE\_BTN\_A\_LEFT\_TRIGGER}{Left trigger binary input}
\tblx{DS5W\_ISTATE\_BTN\_A\_RIGHT\_TRIGGER}{Right trigger binary input}
\tblx{DS5W\_ISTATE\_BTN\_A\_SELECT}{Select / Share button}
\tblx{DS5W\_ISTATE\_BTN\_A\_MENU}{Menu Button}
\tblx{DS5W\_ISTATE\_BTN\_A\_LEFT\_STICK}{Left stick push button}
\tblx{DS5W\_ISTATE\_BTN\_A\_RIGHT\_STICK}{Right stick push button}

% Button B
\tblx{DS5W\_ISTATE\_BTN\_B\_PLAYSTATION\_LOGO}{PlayStation logo button}
\tblx{DS5W\_ISTATE\_BTN\_B\_PAD\_BUTTON}{The touch-pads integrated button}
\tblx{DS5W\_ISTATE\_BTN\_B\_MIC\_BUTTON}{Microphone mute button}

% Outstate
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_LEFT}{Left player indicator LED bit-mask}
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_MIDDLE\_LEFT}{Left middle player indicator LED bit-mask}
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_MIDDLE}{Middle player indicator LED bit-mask}
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_MIDDLE\_RIGHT}{Right middle player indicator LED bit-mask}
\tblx{DS5W\_OSTATE\_PLAYER\_LED\_RIGHT}{Right player indicator LED bit-mask}

\subsection{Types}
\paragraph{DeviceEnumInfo} This struct contains all internal data required for the controller enumeration. You should not read or write any of the internal data directly. The struct can be freely user allocated with random data. It will be initialized by the corresponding function call, don't use it before it got initialized by the corresponding function.

\paragraph{DeviceContext} This struct contains all internal data for reading and writing to the controller. You should not read or write any of the internal data directly. The struct can be freely user allocated with random data. It will be initialized by the corresponding function call, don't use it before it got initialized by the corresponding function. It is very important to free this data with the corresponding function before the application exits or memory is reused. 

\label{APIRef_Types_analstick}
\paragraph{AnalogStick} This struct represent the XY position of one analog stick. Make sure to implement dead zones by yourself! \\

\tbly{int8\_t}{x}{X Position (left to right) of the analog stick.} \\

\tbly{int8\_t}{y}{Y Position (top to bottom) of the analog stick.} \\

\label{APIRef_Types_vec3}
\paragraph{Vector3, Vec3} Represents a three component 16-Bit vector \\

\tbly{int16\_t}{x}{X Component.} \\

\tbly{int16\_t}{y}{Y Component.} \\

\tbly{int16\_t}{z}{Z Component.} \\

\label{APIRef_Types_color}
\paragraph{Color} RGB 8-Bit color components. The library also provides several conversion functions to turn several color formats into 8-Bit RGB values.\\

\tbly{uint8\_t}{r}{R - Red color channel.}\\

\tbly{uint8\_t}{g}{G - Green color channel.}\\

\tbly{uint8\_t}{b}{B - Blue color channel.}\\

\label{APIRef_Types_touch}
\paragraph{Touch} This struct contains information about a single fingers touch position. \\

\tbly{int8\_t}{x}{X Position of the finger (left to right).} \\

\tbly{int8\_t}{y}{Y Position of the finger (top to bottom).} \\

\label{APIRef_Types_micled}
\paragraph{MicLed} Enum class representation the state of the microphone LED. \\

\tblx{OFF}{Microphone LED is completely off.}
\tblx{ON}{Microphone LED is on.}
\tblx{PULSE}{Microphone LED is pulsing.}


\label{APIRef_Types_tfxt}
\paragraph{TriggerEffectType} Enum class: feedback / effect type of the adaptive trigger.\\

\tblx{NoResitance}{Adaptive trigger is disabled. Will provide no resistance.}
\tblx{ContinuousResitance}{Adaptive trigger will provide a continuous resistance from a specific starting point.}
\tblx{SectionResitance}{Adaptive trigger will provide a force fixed resistance on a defined section.}
\tblx{EffectEx}{Adaptive trigger will execute an extended effect.}
\tblx{Calibrate}{Adaptive trigger will enter an fixed function calibration program. Still experimental use only!}

\label{APIRef_Types_trigfx}
\paragraph{TriggerEffect}
This struct represents an adaptive trigger effect. The first param is the type. The other is a union over structs for each type.\\

\tbly{\hyperref[APIRef_Types_tfxt]{TriggerEffectType}}{effectType}{Type of the effect. Chose next data according to this parameter.}\\

\noindent
When \texttt{effectType} == \texttt{NoResitance} no parameter needs to be set!\\
When \texttt{effectType} == \texttt{Calibrate} no parameter needs to be set!\\
When \texttt{effectType} == \texttt{ContinuousResitance}:\\

\tbly{uint8\_t}{Continuous.startPosition}{Start position of the continuous force.}\\

\tbly{uint8\_t}{Continuous.endPosition}{Force applied.}\\

\noindent
When \texttt{effectType} == \texttt{SectionResitance}:\\

\tbly{uint8\_t}{Section.startPosition}{Start of force increased area.}\\

\tbly{uint8\_t}{Section.force}{End of force increased area.}\\

\noindent
When \texttt{effectType} == \texttt{EffectEx}:\\

\tbly{uint8\_t}{EffectEx.startPosition}{Start positions of the effect.}\\

\tbly{bool}{EffectEx.keepEffect}{Indicates weather the effect should keep playing (vibration) when the trigger is fully pressed.}\\

\tbly{uint8\_t}{EffectEx.beginForce}{Force for the section with trigger value $\geq 128$.}\\

\tbly{uint8\_t}{EffectEx.middleForce}{Force for the section with trigger value $\leq 128$.}\\

\tbly{uint8\_t}{EffectEx.endForce}{Force applied when the trigger is fully pressed / would go beyond 255.}\\

\tbly{uint8\_t}{EffectEx.frequency}{Frequency with witch the effect is executed. More a scalar value to scale between two fixed frequency than an real frequency parameter.}\\


\label{APIRef_Types_ledbr}
\paragraph{LedBrightness} Enum class representation the brightness of the player indication LEDs.\\

\tblx{LOW}{Low brightness player indication LEDs.}
\tblx{MEDIUM}{Medium brightness player indication LEDs.}
\tblx{HIGH}{High brightness player indication LEDs.}

\label{APIRef_Types_pleds}
\paragraph{PlayerLeds} Struct defining the player LDEs state.\\

\tbly{Bitmask / uint8\_t}{bitmask}{Bitmask of the enabled player indication LEDs. Or together all enabled LEDs by using the \texttt{DS5W\_OSTATE\_PLAYER\_LED\_XXXXX} macros.}\\

\tbly{bool}{playerLedFade}{Indicates weather the player LEDs should fade in when enabled.}\\

\tbly{\hyperref[APIRef_Types_ledbr]{LedBrightness}}{brightness}{Brightness of the player LEDs.}\\


\paragraph{DS5InputState} 
This struct represents the input state of a DualSense controller. It is used to read all input data.\\

\tbly{\hyperref[APIRef_Types_analstick]{AnalogStick}}{leftStick}{Represents the position of the left analog stick.}\\

\tbly{\hyperref[APIRef_Types_analstick]{AnalogStick}}{rightStick}{Represents the position of the right analog stick.}\\

\tbly{uint8\_t}{leftTrigger}{8-Bit position of the left trigger. No dead zones required!}\\

\tbly{uint8\_t}{rightTrigger}{8-Bit position of the right trigger. No dead zones required!}\\

\tbly{Bitmask / uint8\_t}{buttonsAndDpad}{Bitmask of the PlayStation button and the DPAD. Check the active state with the \texttt{DS5W\_ISTATE\_BTX\_XXXXX} and \texttt{DS5W\_ISTATE\_DPAD\_XXXXX} macros.}\\

\tbly{Bitmask / uint8\_t}{buttonsA}{Bitmask of the controllers buttons (Set A). Check the active state with the \texttt{DS5W\_ISTATE\_BTN\_A\_XXXXX} macros.}\\

\tbly{Bitmask / uint8\_t}{buttonsB}{Bitmask of the controllers buttons (Set B). Check the active state with the \texttt{DS5W\_ISTATE\_BTN\_B\_XXXXX} macros.}\\

\tbly{\hyperref[APIRef_Types_vec3]{Vector3}}{accelerometer}{Acceleration vector.}\\

\tbly{\hyperref[APIRef_Types_vec3]{Vector3}}{gyroscope}{Orientation vector.}\\

\tbly{\hyperref[APIRef_Types_touch]{Touch}}{touchPoint1}{First touch point.}\\

\tbly{\hyperref[APIRef_Types_touch]{Touch}}{touchPoint2}{Second touch point.}\\
		
\tbly{uint32\_t}{currentTime}{Time that the input state was read at (measured in 0.33 microseconds)}\\

\tbly{uint32\_t}{deltaTime}{Time since the previous input state was read (measured in 0.33 microseconds)}\\

\tbly{bool}{headPhoneConnected}{Indicates weather a plug is present in the headphone jack. Will also trigger on an extension cord with no headphone connected!}\\

\tbly{uint8\_t}{leftTriggerFeedback}{Indicates the pressing force when the left adaptive trigger is active.}\\

\tbly{uint8\_t}{rightTriggerFeedback}{Indicates the pressing force when the right adaptive trigger is active.}\\


\paragraph{DS5OutputState}
This struct represents the output state of a DualSense controller. It is used to set all output data. \\

\tbly{uint8\_t}{leftRumble}{Force of the left (hard) rumble motor.}\\

\tbly{uint8\_t}{rightRumble}{Force of the right (soft) rumble motor.}\\

\tbly{uint8\_t}{rumbleStrength}{Strength of the rumble/haptic (trigger) motors. First 4 bits (0-3) represent the rumble motors and last 4 (4-7) represent the trigger's haptics strength.}\\

\tbly{\hyperref[APIRef_Types_micled]{MicLed}}{microphoneLed2}{State of the microphone LED.}\\

\tbly{bool}{disableLeds}{When active the lightbar will be set to the default PS5 blue.}\\

\tbly{\hyperref[APIRef_Types_pleds]{PlayerLeds}}{playerLeds}{State of the player LEDs.}\\

\tbly{\hyperref[APIRef_Types_color]{Color}}{lightbar}{RGB Color of the lightbar. No affect when \texttt{disableLeds} is \texttt{true}.}\\

\tbly{\hyperref[APIRef_Types_trigfx]{TriggerEffect}}{leftTriggerEffect}{Effect of the left adaptive trigger.}\\

\tbly{\hyperref[APIRef_Types_trigfx]{TriggerEffect}}{rightTriggerEffect}{Effect of the right adaptive trigger.}
\newpage

\subsection{Functions}

\paragraph{DS5W::enumDevices(...)}
Enumerate all connected controllers.\\


\paragraph{DS5W::initDeviceContext(...)}
Initializes the context for a specific controller.\\


\paragraph{DS5W::freeDeviceContext(...)}
Frees a context from a controller witch is no longer required.\\


\paragraph{DS5W::reconnectDevice(...)}
Trys to reconnect a removed device.\\


\paragraph{DS5W::getDeviceInputState(...)}
Retrieve the current input state of the device.\\


\paragraph{DS5W::setDeviceOutputState(...)}
Sets the desired output state of the device.\\


\paragraph{DS5W::color\_R32G32B32\_FLOAT(...)} 
Converts a three component (RGB) normalized float color to the internal RGB 8-Bit formate.\\


\paragraph{DS5W::color\_R32G32B32A32\_FLOAT(...)}
Converts a four component (RGBA) normalized float color to the internal RGB 8-Bit formate.\\


\paragraph{DS5W::color\_R8G8B8A8\_UCHAR(...)}
Converts a four component (RGBA) unsigned char color (8-Bit) to the internal RGB 8-Bit formate.\\


\paragraph{DS5W::color\_R8G8B8\_UCHAR\_A32\_FLOAT(...)}
Scales a three component (RGB) unsigned char color (8-Bit) by a normalized float (A).\\



\newpage